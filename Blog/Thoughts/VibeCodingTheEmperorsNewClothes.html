<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
        http-equiv="Content-Security-Policy"
          content="script-src 'self' 'unsafe-inline' https://www.sixsideddice.com https://cdn.jsdelivr.net https://kit.fontawesome.com https://code.jquery.com https://www.googletagmanager.com;" />

    <link href="/favicon.ico" rel="icon" type="image/x-icon">
    <title>Vibe Coding: The Emperor&#39;s New Clothes - SixSidedDice.com - Blog</title>
    <link rel="stylesheet" href="https://www.sixsideddice.com/css//bootstrapdarkly.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-okaidia.css" integrity="sha256-nwDipdLn93O1CZGoRDor0i4CLmDQb+mdg/yaYMUCuLM=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://www.sixsideddice.com/css/site.css">
    <link rel="stylesheet" href="/Blog/site.css">
    <script src="https://kit.fontawesome.com/d22effaf67.js" crossorigin="anonymous"></script>
    <script type="module" src="https://www.sixsideddice.com/js/header.js"></script>
    <script type="module" src="https://www.sixsideddice.com/js/footer.js"></script>
    
    
    <!-- Meta -->
    <meta name="robots" content="index, follow">
    <meta name="description" content="Vibe coding tools promise to make software development faster and easier, but history tells a cautionary tale. Like 4GLs and Model-Driven Architecture before them, these tools risk repeating the cycle of hype, complexity, and disillusionment. Real engineering practices and not just "vibes" remain essential for building systems that last.">
    <meta name="author" content="Lee Sanderson">
    <meta name="copyright" content="Lee Sanderson">
    <meta name="keywords" content="CodingAssistants AI VibeCoding Thoughts">
    <link rel="me" type="text/html" href="https://twitter.com/SixSidedDev">
    <link rel="me" type="text/html" href="https://github.com/LeeSanderson">
    <link rel="me" type="text/html" href="https://www.linkedin.com/in/lee-sanderson">
    <link rel="canonical" href="https://www.sixsideddice.com/Blog/Thoughts/VibeCodingTheEmperorsNewClothes.html">
    <!-- Twitter card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@SixSidedDev">
    <meta name="twitter:creator" content="@SixSidedDev">
    <meta name="twitter:title" content="Vibe Coding: The Emperor's New Clothes">
    <meta name="twitter:description" content="Vibe coding tools promise to make software development faster and easier, but history tells a cautionary tale. Like 4GLs and Model-Driven Architecture before them, these tools risk repeating the cycle of hype, complexity, and disillusionment. Real engineering practices and not just "vibes" remain essential for building systems that last.">
    <meta name="twitter:image" content="https://www.sixsideddice.com/Blog/Thoughts/VibeCodingTheEmperorsNewClothes.png">
    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta name="title" property="og:title" content="Vibe Coding: The Emperor's New Clothes">
    <meta name="description" property="og:description" content="Vibe coding tools promise to make software development faster and easier, but history tells a cautionary tale. Like 4GLs and Model-Driven Architecture before them, these tools risk repeating the cycle of hype, complexity, and disillusionment. Real engineering practices and not just "vibes" remain essential for building systems that last.">
    <meta name="image" property="og:image" content="https://www.sixsideddice.com/Blog/Thoughts/VibeCodingTheEmperorsNewClothes.png">
    <meta property="og:url" content="https://www.sixsideddice.com/Blog/Thoughts/VibeCodingTheEmperorsNewClothes.html">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7PG42VD9X0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-7PG42VD9X0');
    </script>
    <!-- End Google Tag Manager -->
</head>
<body>
    <six-sided-header></six-sided-header>
    <div class="container">
        <main role="main" class="pb-3">
            
<div class="article-header">
    <span class="article-date">May 01, 2025</span>
    
    <span class="article-tags">
        <span class="badge badge-info">CodingAssistants</span>
        <span class="badge badge-info">AI</span>
        <span class="badge badge-info">VibeCoding</span>
        <span class="badge badge-info">Thoughts</span>
    </span>
</div>
<div data-pagefind-body>
<h1 id="vibe-coding-the-emperors-new-clothes" class="sr-only" data-hero-heading="true">Vibe Coding: The Emperor's New Clothes</h1>
<img class="hero-image" src="VibeCodingTheEmperorsNewClothes.png" alt="Vibe Coding: The Emperor's New Clothes"/>
<p>Every generation of software development seems to discover a new <a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank">silver bullet</a>. A tool,  platform, or magical abstraction that will finally eliminate the hard work of building quality software systems. Today’s iteration of that ancient dream is <em>vibe coding</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Vibe_coding" target="_blank">Vibe coding</a> refers to the new wave of tools that promise you can &quot;build software by feel&quot; by using natural language prompts rather than traditional, structured coding. These tools, powered by AI, claim to encourage a faster, more intuitive approach to building applications. The goal is simple: make programming so easy and abstract that anyone can do it without deep technical expertise.</p>
<p>The promises are intoxicating: build faster, ship faster, learn less, deliver more. Everyone can code! Developers are liberated! Business users become engineers!</p>
<p>If this sounds familiar, it should. We’ve heard it all before.</p>
<p>Before we dive in, it’s important to frame this article properly:  <strong>I write this not as a cynic, but as a software craftsperson with over 30 years of experience</strong> building, maintaining, and rescuing real-world systems. I’ve seen several waves of transformational promises and observed how easily optimism can blind us to enduring software realities.</p>
<p>The purpose of this critique is not to dismiss innovation, but to offer a reasoned perspective: why vibe coding is unlikely to replace the careful, disciplined practices that professional software engineering demands.</p>
<h2 id="a-familiar-pattern-4gls-and-the-cycle-of-hype">A Familiar Pattern: 4GLs and the Cycle of Hype</h2>
<p>In the 1980s and 1990s, the industry was enthralled by Fourth Generation Languages (4GLs). Tools like <a href="https://en.wikipedia.org/wiki/PowerBuilder" target="_blank">PowerBuilder</a>, <a href="https://en.wikipedia.org/wiki/Oracle_Forms" target="_blank">Oracle Forms</a>, and <a href="https://en.wikipedia.org/wiki/Visual_Basic_(classic)" target="_blank">Visual Basic</a> promised to abstract away the complexity of software development. &quot;You don’t need software engineers,&quot; they said. &quot;Just someone who can drag and drop.&quot;</p>
<p>And to some extent, they delivered at first. For simple CRUD applications and small departmental tools, 4GLs accelerated development dramatically. But as applications grew, so did the problems:</p>
<ul>
<li>Lack of good engineering discipline led to spaghetti code that mixed business logic with UI concerns that made systems hard to maintain and impossible to unit test.</li>
<li>Poor structure led to debugging and optimisation nightmares.</li>
<li>Scaling beyond the initial vision often meant a complete rewrite.</li>
</ul>
<p>Eventually, organisations rediscovered why software engineering disciplines such as design patterns, testing, version control, and maintainability existed in the first place. 4GLs never replaced engineering; they simply shifted the work from initial development to expensive maintenance and rework down the road.</p>
<h2 id="the-false-dawn-of-model-driven-architecture">The False Dawn of Model-Driven Architecture</h2>
<p>Not long after the 4GL wave ebbed, another movement promised to eliminate complexity: <a href="https://en.wikipedia.org/wiki/Model-driven_architecture" target="_blank">Model-driven architecture</a> (MDA). Pioneered in the early 2000s, MDA envisioned a future where software would be designed using high-level models (typically UML diagrams) from which code could be automatically generated. Developers wouldn’t need to worry about the gritty details of implementation. Models would <em>be</em> the system.</p>
<p>The industry loved the idea. Tools vendors, standards bodies, and consultants rushed to embrace MDA as the new frontier. Popular platforms like <a href="https://en.wikipedia.org/wiki/IBM_Rational_Rose" target="_blank">IBM Rational Rose</a>, <a href="https://andromda.sourceforge.net/" target="_blank">AndroMDA</a>, <a href="https://en.wikipedia.org/wiki/Enterprise_Architect_(software)" target="_blank">Sparx Systems Enterprise Architect</a>, and <a href="https://en.wikipedia.org/wiki/OptimalJ" target="_blank">OptimalJ</a> were positioned as essential to this model-driven future. You could design your application architecture, database schemas, and even user interfaces in modelling tools and then &quot;press a button&quot; to generate large portions of the codebase.</p>
<p>Yet once again, the reality fell short of the dream:</p>
<ul>
<li>The generated code was often bloated, inefficient, and hard to understand.</li>
<li>Making even small changes required either tweaking the model (which could be complex and error-prone) or manually hacking the generated code which effectively defeated the purpose of using these tools in the first place.</li>
<li>Models became massive, monolithic artifacts that were difficult to maintain as systems evolved.</li>
<li>There was a significant impedance mismatch between abstract models and real-world system needs.</li>
</ul>
<p>In theory, MDA would free developers from low-level thinking. In practice, it trapped teams in layers of abstraction that made change and innovation <em>harder</em>, not easier.</p>
<p>Today, MDA survives mainly as a cautionary tale in many organizations. It is another example of how efforts to bypass complexity often end up creating new, different complexities instead.</p>
<h2 id="the-allure-and-illusion-of-vibe-coding">The Allure (and Illusion) of Vibe Coding</h2>
<p>Today's vibe coding tools, supercharged with AI, market themselves with fresh terminology but familiar promises:</p>
<ul>
<li>&quot;Don’t worry about architecture, just describe what you want!&quot;</li>
<li>&quot;Focus on outcomes, not code!&quot;</li>
<li>&quot;Natural language is the new programming language!&quot;</li>
</ul>
<p>The underlying assumption is that traditional engineering practices are unnecessary overhead and relics of a pre-AI world. Why worry about dependency management, error handling, or long-term maintainability when you can simply &quot;vibe it out&quot; and have the system figure it out for you?</p>
<p>Except... the hard problems haven't gone away. Complexity doesn't vanish just because you describe it differently. Ambiguity, edge cases, performance concerns, scalability, security are <em>engineering</em> challenges, not <em>coding syntax</em> challenges.</p>
<p>If vibe coding leads to brittle, unmaintainable systems (and there's <a href="https://arxiv.org/abs/2304.10778" target="_blank">already evidence</a> that it often does) then organisations will pay for that technical debt, just as they did with the first generation of 4GLs and MDA platforms. Except this time, the scale (and the consequences) could be even larger.</p>
<h2 id="why-traditional-software-engineering-still-matters">Why Traditional Software Engineering Still Matters</h2>
<p>There are timeless reasons why professional software engineering practices exist:</p>
<ul>
<li><strong>Quality</strong>: Code that’s understandable, testable, and resilient.</li>
<li><strong>Maintainability</strong>: Systems that can be evolved over years, not just demoed once.</li>
<li><strong>Scalability</strong>: Architectures that can grow with business needs.</li>
<li><strong>Security</strong>: Systems that aren't vulnerable by default.</li>
<li><strong>Collaboration</strong>: Codebases that teams can work on safely and productively.</li>
</ul>
<p>Vibe coding tools tend to prioritise the initial developer experience i.e. what it feels like to create a prototype. But real-world software systems are <em>maintained and evolved</em> far longer than they are <em>initially created</em>. The &quot;vibes&quot; wear off. The prototypes ossify into production systems, and then the real work begins.</p>
<h2 id="conclusion-a-sober-prediction">Conclusion: A Sober Prediction</h2>
<p>Does this mean vibe coding is worthless? Of course not. Like 4GLs and MDA before them, these tools have their place:</p>
<ul>
<li>Rapid prototyping</li>
<li>Internal tools</li>
<li>MVPs and proof-of-concepts</li>
<li>Empowering non-developers to create lightweight solutions</li>
</ul>
<p>But for serious, large-scale systems? For anything where failure has consequences?<br />
Software engineering with its careful and disciplined approach to crafting quality will remain essential.</p>
<p>In time, organisations will realise that vibe coding is another case of <em>The Emperor’s New Clothes</em>: a beautiful fantasy, eagerly sold and bought, until reality asserts itself. And once again, professional engineers will be called in to rebuild, refactor, and rescue.</p>
<p>The tools change. The principles endure.</p>

</div>
        </main>
    </div>

    <six-sided-footer></six-sided-footer>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" integrity="sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js" integrity="sha256-2N+3bVl+vOCJyZ9ZbH9Eb99XKT/53oT5V8eRbB8bFcA=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-33Qw0lN3qo7tLZL4c7vDLCapRUs+gNtQRaVIOHk4Ors=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.11.0/dist/mermaid.min.js"></script>
    
    <script>
        $(function() {
            mermaid.initialize({ startOnLoad: true, theme: 'dark' });
        });
    </script>
</body>
</html>
